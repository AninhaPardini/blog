import MdxLayout from '../../../components/mdx-layout'
 
# Guia de componentes - para quem tem pressa!

Um Shadow Dom como √© mais conhecido os componentes no JS Vanilla, s√£o como c√°psulas que cont√©m seus elementos com escopo pr√≥prio, e que tamb√©m √© poss√≠vel escolher se quer que ele seja edit√°vel ou n√£o variando o seu mode entre ‚Äúopen‚Äù ou ‚Äúclosed‚Äù.

## Uma base simples
```javascript
class Component extends HTMLElement {
  constructor() {
    super(); // Chamar o construtor da classe pai (HTMLElement)
    this.shadowDom = this.attachShadow({ mode: "open" });

    // Criar o elemento h1 dentro da sombra
    const componentRoot = document.createElement("h1");
    componentRoot.textContent = this.getAttribute("title"); // propiedade

    // Estilizar o componente
    const style = document.createElement("style");
    style.textContent = `h1 { color: red; }`;

    // Adicionar elementos √† sombra
    this.shadowDom.appendChild(componentRoot);
    this.shadowDom.appendChild(style);
  }
}

// Registrar o elemento personalizado
customElements.define("my-component", Component);
```

Chamando dentro da p√°gina:

```javascript
<script src="./src/Components/CardNews.js" defer></script>
```

> ‚ö†Ô∏è O defer √© importante para que o component seja carregado apenas depois que o dom da p√°gina se carregue.

## ‚ú® Ainda melhor!

Para melhorar e deixar o c√≥digo do componente mais limpo, voc√™ pode seguir algumas pr√°ticas e simplifica√ß√µes!

1. Use **aspas consistentes** para atributos de strings;
2. Utilize a nota√ß√£o de **template literals** para melhorar a legibilidade de strings longas;
3. Separe o estilo CSS em uma string de template literal;
4. Use o *build()* e *styles()* para organizar os c√≥digos de constru√ß√£o e estiliza√ß√£o;

```javascript
class ComponentExpert extends HTMLElement {
  constructor() {
    super(); // Chamar o construtor da classe pai (HTMLElement)
    this.shadowDom = this.attachShadow({ mode: "open" });
    this.shadowDom.appendChild(this.build());
    this.shadowDom.appendChild(this.styles());
  }

  build() {
    const componentRoot = document.createElement("div");
    componentRoot.classList.add("root");

    const childDiv = document.createElement("div");
    childDiv.classList.add("child");

    const titleDiv = document.createElement("h1");
    titleDiv.textContent = `Hello ${(this.getAttribute("name") || "World")}`;

    const linkDiv = document.createElement("a");
    linkDiv.textContent = "Link Util";
    linkDiv.href = this.getAttribute("link") || "https://linkdefault.com.br";

    childDiv.appendChild(linkDiv);
    childDiv.appendChild(titleDiv);

    componentRoot.appendChild(childDiv);

    return componentRoot;
  }

  styles() {
    const style = document.createElement("style");
    style.textContent = `
      .root {
        width: 100%;
        background-color: #dedede;
      }

      .child {
        width: 50%;
        background-color: pink;
      }

      .child h1 {
        color: #dedede;
      }
    `;

    return style;
  }
}

customElements.define("component-card", ComponentExpert);
```

√â uma boa conduta em uma props definir um valor padr√£o para ela, para caso os dados n√£o sejam carregados ou o usu√°rio n√£o tenha enviado os par√¢metros.

## üîç Usando functions ao seu favor!
As fun√ß√µes vieram para ser usadas de forma que **facilite** o trabalho e **legibilidade** do c√≥digo, ent√£o √© importante utiliza-l√° para deixar seu c√≥digo mais **funcional**!

Neste c√≥digo eu usei algumas formas de armazenar valores, concatenar e validar, al√©m de usar a desestrutura√ß√£o a meu favor no objeto attributes.

```javascript
class ComponentExpert extends HTMLElement {
    constructor() {
        super(); // Chamar o construtor da classe pai (HTMLElement)
        this.shadowDom = this.attachShadow({ mode: "open" });
        this.shadowDom.appendChild(this.build());
        this.shadowDom.appendChild(this.styles());
    }

    build() {
        function createCustomElement(elementType, classNames = [], attributes = {}, content = '') {
            const element = document.createElement(elementType);

            // Adicione classes CSS
            if (classNames.length > 0) {
                element.classList.add(...classNames);
            }

            // Adicione atributos
            for (const [key, value] of Object.entries(attributes)) {
                element.setAttribute(key, value);
            }

            // Adicione conte√∫do
            if (content !== '') {
                element.textContent = content;
            } else {
                element.textContent = 'Conte√∫do do elemento ' + elementType;

            }

            return element;
        }

        // Exemplo de uso:
        const componentRoot = createCustomElement('div', ['root', 'main'], {
            id: 'main',
            'data-custom': 'root',
        });

        const childElement = createCustomElement('div', ['child'], {
            id: 'childDiv',
            'data-custom': 'child',
        });

        componentRoot.appendChild(childElement);

        const titleElement = createCustomElement('h1', ['title', 'child'], {
            title: 'T√≠tulo do elemento',
            id: 'title',
            'data-custom': 'title',
        }, 'T√≠tulo');

        childElement.appendChild(titleElement);

        return componentRoot;
    }

    styles() {
        const style = document.createElement("style");
        style.textContent = `
            .root {
                width: 100%;
                display: flex;
                justify-content: center;
                color: #333333;

                background-color: #dedede;
            }

            .child {
                width: 50%;
                display: flex;
                justify-content: flex-start;
                aling-itens: center;

                background-color: #d78795;

            }

            .child .title {
                color: #dedede;

            }
        `;

        return style;
    }
}

customElements.define("component-card", ComponentExpert);
```
Quanto mais voc√™ deixar din√¢mico seu componente e seus elementos mais ele vai ser flex√≠vel a diversas situa√ß√µes, um componente pode ser aplicado a uma navbar, um widget de not√≠cia, um header, h√° v√°rias op√ß√µes!

## Quando fazer um componente?

Para saber se deve ou n√£o construir um componente em algo √© preciso pensar na funcionalidade daquilo, vai se repetir v√°rias vezes? Vai ter que aparecer com op√ß√µes diferentes em outra p√°gina? √â analisar o qual m√≥vel √© esse item e se ele ir√° ser reutiliz√°vel ou n√£o.

export default function MDXPage({ children }) {
  return <MdxLayout>{children}</MdxLayout>
}
